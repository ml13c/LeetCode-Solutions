DESCRIPTION:
On day 1, one person discovers a secret.

You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.

Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.
CODE ATTEMPT 1:
class Solution {
public:
    // Checks if a person who discovered the secret on 'day_discovered'
    // still remembers it on 'current_day'
    bool remembers_secret(int day_discovered, int current_day, int forget) {
        return current_day - day_discovered < forget;
    }

    // Checks if one person who discovered the secret on 'day_discovered'
    // can tell someone new on 'current_day'
    int how_many_oneperson_tells(int day_discovered, int current_day, int delay, int forget) {
        if (remembers_secret(day_discovered, current_day, forget) &&
            current_day - day_discovered >= delay) {
            return 1; // they tell exactly one person
        }
        return 0;
    }

    int peopleAwareOfSecret(int n, int delay, int forget) {
        // Each element stores the day a person discovered the secret
        std::vector<int> discovered_days;
        discovered_days.push_back(1); // one person knows on day 1

        for (int day = 2; day <= n; day++) {
            std::vector<int> new_people;
            for (int d : discovered_days) {
                if (how_many_oneperson_tells(d, day, delay, forget)) {
                    new_people.push_back(day); // new person learns today
                }
            }
            // Add all new people to the group
            discovered_days.insert(discovered_days.end(), new_people.begin(), new_people.end());
        }

        // Count how many still remember by day n
        int count = 0;
        for (int d : discovered_days) {
            if (remembers_secret(d, n, forget)) {
                count++;
            }
        }
        return count;
    }
};

WHY IT DOESNT WORK EXPLANATION:
The way this solution works is we check each person individually. While this does work it uses up too much memory and is not a viable solution.
The first function checks if the person remembers by calculating what day it is and if they will remember that day or not. The second function checks how many people one tells
by checking if they remember the secret and adds 1 until they forget. This happens for each person until they forget.
CODE SOLUTION:
class Solution {
public:
    int peopleAwareOfSecret(int n, int delay, int forget) {
        const int MOD = 1e9 + 7;

        // dp[i] = number of people who discover the secret on day i
        std::vector<long long> dp(n + 1, 0);
        dp[1] = 1; // one person knows on day 1

        for (int day = 1; day <= n; day++) {
            long long people = dp[day];
            if (people == 0) continue;

            // They can start telling at day + delay
            int start = day + delay;
            // They stop telling at day + forget
            int end = day + forget;

            for (int next = start; next < end && next <= n; next++) {
                dp[next] = (dp[next] + people) % MOD;
            }
        }

        // Count how many still remember by day n
        long long ans = 0;
        for (int day = n - forget + 1; day <= n; day++) {
            if (day >= 1) ans = (ans + dp[day]) % MOD;
        }
        return (int)ans;
    }
};

EXPLANATION
